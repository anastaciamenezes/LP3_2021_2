import COMMANDS, { TransformArgumentsReply } from './commands';
import { RedisCommand, RedisModules, RedisReply } from './commands';
import { RedisLuaScript, RedisLuaScripts } from './lua-script';
import { RedisClientOptions } from './client';
declare type RedisMultiCommandSignature<C extends RedisCommand, M extends RedisModules, S extends RedisLuaScripts> = (...args: Parameters<C['transformArguments']>) => RedisMultiCommandType<M, S>;
declare type WithCommands<M extends RedisModules, S extends RedisLuaScripts> = {
    [P in keyof typeof COMMANDS]: RedisMultiCommandSignature<(typeof COMMANDS)[P], M, S>;
};
declare type WithModules<M extends RedisModules, S extends RedisLuaScripts> = {
    [P in keyof M]: {
        [C in keyof M[P]]: RedisMultiCommandSignature<M[P][C], M, S>;
    };
};
declare type WithScripts<M extends RedisModules, S extends RedisLuaScripts> = {
    [P in keyof S]: RedisMultiCommandSignature<S[P], M, S>;
};
export declare type RedisMultiCommandType<M extends RedisModules = {}, S extends RedisLuaScripts = {}> = RedisMultiCommand<M, S> & WithCommands<M, S> & WithModules<M, S> & WithScripts<M, S>;
export interface MultiQueuedCommand {
    args: TransformArgumentsReply;
    preservedArguments?: unknown;
    transformReply?: RedisCommand['transformReply'];
}
export declare type RedisMultiExecutor = (queue: Array<MultiQueuedCommand>, chainId?: symbol) => Promise<Array<RedisReply>>;
export default class RedisMultiCommand<M extends RedisModules, S extends RedisLuaScripts> {
    #private;
    static extend<M extends RedisModules, S extends RedisLuaScripts>(clientOptions?: RedisClientOptions<M, S>): new (...args: ConstructorParameters<typeof RedisMultiCommand>) => RedisMultiCommandType<M, S>;
    static create<M extends RedisModules = {}, S extends RedisLuaScripts = {}>(executor: RedisMultiExecutor, clientOptions?: RedisClientOptions<M, S>): RedisMultiCommandType<M, S>;
    get v4(): Record<string, any>;
    constructor(executor: RedisMultiExecutor, clientOptions?: RedisClientOptions<M, S>);
    commandsExecutor(command: RedisCommand, args: Array<unknown>): this;
    scriptsExecutor(script: RedisLuaScript, args: Array<unknown>): this;
    addCommand(args: TransformArgumentsReply, transformReply?: RedisCommand['transformReply']): this;
    exec(execAsPipeline?: boolean): Promise<Array<RedisReply>>;
    execAsPipeline(): Promise<Array<RedisReply>>;
}
export {};
